<div class="lrn-qe-edit-form">
    <!-- Graffiticode Link -->
    <div class="lrn-qe-row-flex lrn-qe-margin-bottom-md">
        <div class="lrn-qe-col-xs-12">
            <button type="button" id="editQuestionBtn" style="display: inline-block; padding: 8px 16px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; font-weight: 500; border: none; cursor: pointer;">
                Edit Question ‚Üí
            </button>
        </div>
    </div>
    <script>
        (function() {
            let graffiticodeWindow = null;
            const LANG = '0165'; // Fixed language for this question type
            let lastProcessedItemId = null; // Track last processed item to avoid duplicates
            
            // Handle messages from Graffiticode
            window.addEventListener('message', function(event) {
                // Filter out MetaMask noise
                if (event.data) {
                    // Check if it's a direct MetaMask message
                    if (event.data.target === 'metamask-inpage') {
                        return;
                    }
                    
                    // Check if it's a string containing MetaMask error
                    if (typeof event.data === 'string' && event.data.includes('metamask')) {
                        return;
                    }
                    
                    // Check if it's an object with MetaMask error
                    if (typeof event.data === 'object' && event.data.error && 
                        typeof event.data.error === 'string' && event.data.error.includes('metamask')) {
                        return;
                    }
                }
                
                // Log ALL incoming messages for debugging
                console.log('üì® Message received from:', event.origin);
                console.log('   Message type:', event.data.type);
                console.log('   Full message data:', JSON.stringify(event.data, null, 2));
                
                // Verify origin for security (allow both production and local)
                if (event.origin !== 'https://graffiticode.com' && event.origin !== 'http://localhost:3000') {
                    console.log('   ‚ö†Ô∏è Message rejected - invalid origin');
                    return;
                }
                
                console.log('   ‚úÖ Message accepted - valid origin');
                
                // Handle different message types from Graffiticode
                if (event.data.type === 'graffiticode-ready') {
                    // Graffiticode editor is ready
                    console.log('üöÄ Graffiticode editor is ready');
                } else if (event.data.type === 'item-created') {
                    console.log('üìù Processing item-created message');
                    console.log('   Item ID:', event.data.itemId);
                    
                    // Prevent processing the same message twice
                    if (lastProcessedItemId === event.data.itemId) {
                        console.log('   ‚è≠Ô∏è Skipping - already processed this item ID');
                        return;
                    }
                    lastProcessedItemId = event.data.itemId;
                    
                    // New item was created in Graffiticode
                    console.log('   ‚ú® Creating new item in Learnosity')
                    
                    // Initialize data structure
                    let currentData = {
                        gcItemId: event.data.itemId,
                        validation: { points: 0, ranges: {}, cells: {} },
                        interaction: { type: "table", v: "0.0.1", cells: {}, columns: {} }
                    };
                    console.log('   üì¶ Initial data structure:', JSON.stringify(currentData, null, 2));
                    
                    // Find the actual data input field
                    const dataContainer = document.querySelector('[data-lrn-qe-input="data"]');
                    let dataInput = null;
                    
                    if (dataContainer) {
                        dataInput = dataContainer.querySelector('input, textarea');
                        if (!dataInput && dataContainer.value !== undefined) {
                            dataInput = dataContainer;
                        }
                    }
                    
                    if (dataInput) {
                        console.log('   üìù Found data input field:', dataInput.tagName, dataInput.id || '(no id)');
                        dataInput.value = JSON.stringify(currentData);
                        console.log('   üì§ Updated data field with:', dataInput.value);
                        
                        // Trigger events to notify Learnosity of the change
                        dataInput.dispatchEvent(new Event('input', { bubbles: true }));
                        dataInput.dispatchEvent(new Event('change', { bubbles: true }));
                        console.log('   üîî Dispatched input and change events');
                    } else {
                        console.error('   ‚ùå Could not find data input field');
                    }
                } else if (event.data.type === 'data-updated') {
                    // Compiled data was updated in Graffiticode editor
                    console.log('üîÑ Processing data-updated message');
                    console.log('   Item ID:', event.data.itemId);
                    console.log('   Received data:', JSON.stringify(event.data.data, null, 2))
                    
                    // Find the actual visible input element
                    const dataContainer = document.querySelector('[data-lrn-qe-input="data"]');
                    
                    // Look for all possible input elements
                    let dataInput = null;
                    
                    // Method 1: Look inside the container for actual input/textarea
                    if (dataContainer) {
                        const inputs = dataContainer.querySelectorAll('input, textarea');
                        // Use the first visible input/textarea
                        dataInput = Array.from(inputs).find(input => input.offsetParent !== null) || inputs[0];
                    }
                    
                    // Method 2: Look for nearby inputs that might be the actual field
                    if (!dataInput) {
                        // Get the parent of the container and look for inputs there
                        const parent = dataContainer?.parentElement;
                        if (parent) {
                            const nearbyInputs = parent.querySelectorAll('input, textarea');
                            dataInput = Array.from(nearbyInputs).find(input => input.offsetParent !== null);
                        }
                    }
                    
                    // Method 3: Look for any visible text input with a label containing "data"
                    if (!dataInput) {
                        const allVisibleInputs = Array.from(document.querySelectorAll('input[type="text"], textarea')).filter(input => input.offsetParent !== null);
                        
                        // Check if any of them are near a label with "data" or "spreadsheet"
                        for (let input of allVisibleInputs) {
                            const label = document.querySelector(`label[for="${input.id}"]`) || 
                                        input.closest('div')?.querySelector('label');
                            if (label && (label.textContent.toLowerCase().includes('data') || 
                                         label.textContent.toLowerCase().includes('spreadsheet'))) {
                                dataInput = input;
                                break;
                            }
                        }
                    }
                    
                    // Last resort: use the container itself if it has a value property
                    if (!dataInput && dataContainer && dataContainer.value !== undefined) {
                        dataInput = dataContainer;
                    }
                    
                    if (dataInput) {
                        console.log('   ‚úÖ Data input found. Type:', dataInput.tagName);
                        console.log('   Current value:', dataInput.value);
                        
                        let currentData = {};
                        
                        // Try to parse existing data
                        try {
                            currentData = dataInput.value ? JSON.parse(dataInput.value) : {};
                            console.log('   üìä Parsed existing data:', JSON.stringify(currentData, null, 2));
                        } catch (e) {
                            console.log('   ‚ö†Ô∏è Could not parse existing data, using empty object');
                            currentData = {};
                        }
                        
                        // Merge the compiled data while preserving gcItemId
                        if (event.data.data) {
                            console.log('   üîÄ Merging with new data from Graffiticode');
                            currentData = {
                                ...currentData,
                                ...event.data.data
                            };
                        }
                        
                        // Make sure gcItemId is still set
                        if (event.data.itemId) {
                            currentData.gcItemId = event.data.itemId;
                        }
                        console.log('   üì¶ Merged data:', JSON.stringify(currentData, null, 2));
                        
                        
                        // Update the input field
                        const newValue = JSON.stringify(currentData);
                        console.log('   üìù Preparing to update field with:', newValue);
                        
                        // Update the input field
                        
                        // Focus the field
                        dataInput.focus();
                        
                        // Clear and set the value using the most compatible method
                        if (dataInput instanceof HTMLInputElement || dataInput instanceof HTMLTextAreaElement) {
                            // Use native setter for React compatibility
                            try {
                                const proto = dataInput instanceof HTMLInputElement ? 
                                    window.HTMLInputElement.prototype : 
                                    window.HTMLTextAreaElement.prototype;
                                const nativeSetter = Object.getOwnPropertyDescriptor(proto, "value").set;
                                
                                if (nativeSetter) {
                                    // Clear first
                                    nativeSetter.call(dataInput, '');
                                    dataInput.dispatchEvent(new Event('input', { bubbles: true }));
                                    
                                    // Set new value
                                    nativeSetter.call(dataInput, newValue);
                                }
                            } catch (e) {
                                dataInput.value = newValue;
                            }
                        } else {
                            // Fallback to direct assignment
                            dataInput.value = newValue;
                        }
                        
                        // Dispatch a single input event
                        const inputEvent = new InputEvent('input', {
                            bubbles: true,
                            cancelable: true,
                            inputType: 'insertReplacementText',
                            data: newValue
                        });
                        dataInput.dispatchEvent(inputEvent);
                        
                        // Dispatch change event
                        dataInput.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Blur after a short delay to finalize
                        setTimeout(() => {
                            dataInput.blur();
                            
                            // Verify the value stuck
                            if (dataInput.value !== newValue) {
                                console.log('   ‚ö†Ô∏è Value did not stick, trying execCommand');
                                // Try using execCommand as last resort
                                dataInput.focus();
                                dataInput.select();
                                document.execCommand('selectAll');
                                document.execCommand('insertText', false, newValue);
                                dataInput.blur();
                            } else {
                                console.log('   ‚úÖ Value successfully updated');
                            }
                        }, 100);
                    } else {
                        console.error('   ‚ùå ERROR: Could not find data input field');
                        console.error('   Document ready state:', document.readyState);
                        console.error('   Available inputs:', document.querySelectorAll('input, textarea').length);
                    }
                } else if (event.data.type === 'item-updated') {
                    // Existing item was updated in Graffiticode
                    console.log('‚ôªÔ∏è Processing item-updated message');
                    console.log('   Updated data:', JSON.stringify(event.data.data, null, 2));
                    
                    // Update the data field with latest info
                    const dataInput = document.querySelector('[data-lrn-qe-input="data"]');
                    if (dataInput && event.data.data) {
                        dataInput.value = JSON.stringify(event.data.data);
                        console.log('   üì§ Updated data field');
                        
                        // Trigger change event for Learnosity
                        const changeEvent = new Event('change', { bubbles: true });
                        dataInput.dispatchEvent(changeEvent);
                        console.log('   üîî Dispatched change event');
                    } else {
                        console.log('   ‚ö†Ô∏è Could not update - missing data input or data');
                    }
                } else {
                    console.log('   ‚ùì Unknown message type:', event.data.type);
                }
            });
            
            // Handle button click
            document.getElementById('editQuestionBtn').addEventListener('click', function() {
                console.log('üñ±Ô∏è Edit Question button clicked');
                
                // Get current data to check if we have an existing item
                const dataInput = document.querySelector('[data-lrn-qe-input="data"]');
                let currentData = {};
                let gcItemId = null;
                
                console.log('üì• Checking for existing data...');
                if (dataInput && dataInput.value) {
                    try {
                        currentData = JSON.parse(dataInput.value);
                        gcItemId = currentData.gcItemId || null;
                        console.log('   Current data:', JSON.stringify(currentData, null, 2));
                        console.log('   Existing gcItemId:', gcItemId);
                    } catch (e) {
                        console.error('   ‚ùå Failed to parse current data:', e);
                    }
                } else {
                    console.log('   No existing data found');
                }
                
                // Only open Graffiticode for new questions (no gcItemId)
                if (gcItemId) {
                    console.log('   ‚ö†Ô∏è Question already has Graffiticode item:', gcItemId);
                    alert('This question already has a Graffiticode item associated with it.');
                    return;
                }
                
                // Check if window is already open
                if (graffiticodeWindow && !graffiticodeWindow.closed) {
                    console.log('   üîÑ Graffiticode window already open, focusing...');
                    graffiticodeWindow.focus();
                    return;
                }
                
                // Build URL with parameters for new item
                const params = new URLSearchParams({
                    lang: LANG,
                    mode: 'learnosity',
                    origin: window.location.origin
                });
                
                console.log('üåê Opening Graffiticode with parameters:');
                console.log('   Language:', LANG);
                console.log('   Mode: learnosity');
                console.log('   Origin:', window.location.origin);
                
                // Open Graffiticode with parameters
                // Automatically detect if running locally
                const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const baseUrl = isLocal ? 'http://localhost:3000/learnosity' : 'https://graffiticode.com/learnosity';
                const fullUrl = `${baseUrl}?${params.toString()}`;
                
                console.log('   Is local environment:', isLocal);
                console.log('   Full URL:', fullUrl);
                
                graffiticodeWindow = window.open(
                    fullUrl,
                    'graffiticode',
                    'width=1200,height=800'
                );
                
                console.log('   ‚úÖ Graffiticode window opened');
            });
        })();
    </script>
    <span data-lrn-qe-label="stimulus"></span>
    <span data-lrn-qe-input="stimulus" class="lrn-qe-ckeditor-lg"></span>
    <!-- Validation -->
    <div class="lrn-qe-tabs" data-lrn-qe-tabs data-lrn-qe-section="validation.content">
        <div class="lrn-qe-tab-item" data-lrn-qe-tab-item>
            <div class="lrn-qe-tab-sub-content">
                <span data-lrn-qe-input="score" class="lrn-qe-inline-block lrn-qe-text-left lrn-qe-form-control-xs lrn-qe-margin-left-sm"></span>
                <span data-lrn-qe-label="score" class="lrn-qe-inline-block lrn-qe-margin-left-sm"></span>
            </div>
            <span data-lrn-qe-input="valid_response"></span>
        </div>
    </div>
    <!-- More Options -->
    <h4 class="lrn-qe-heading" data-lrn-qe-adv-toggle>
        <button type="button" class="lrn-qe-form-label lrn-qe-margin-top-none lrn-qe-more-options" data-lrn-qe-section="more_options.heading">
            <span class="lrn-qe-i-arrow lrn-qe-inline-block" data-lrn-qe-section="more_options.toggle"></span>
            <span class="lrn-qe-inline-block lrn-qe-text-bold">
                <label class="lrn-qe-label lrn-qe-form-label-name" data-lrn-qe-i18n-label="heading.moreOptions" value="More options"></label>
            </span>
        </button>
    </h4>
    <div data-lrn-qe-adv-content data-lrn-qe-section="more_options.content">
        <div class="lrn-qe-row-flex" data-lrn-qe-layout-wrapper>
            <div class="lrn-qe-col-xs-12 lrn-qe-col-sm-6">
                <span data-lrn-qe-input="instant_feedback" class="lrn-qe-inline-block"></span>
                <span data-lrn-qe-label="instant_feedback" class="lrn-qe-inline-block lrn-qe-margin-left-sm"></span>
            </div>
        </div>
    </div>
    <!-- Spreadsheet Configuration -->
    <div class="lrn-qe-row-flex lrn-qe-margin-top-md">
        <div class="lrn-qe-col-xs-12">
            <span data-lrn-qe-label="data"></span>
            <span data-lrn-qe-input="data"></span>
        </div>
    </div>
</div>
